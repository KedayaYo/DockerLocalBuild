!(function (e) { if (typeof exports === 'object' && typeof module !== 'undefined') module.exports = e(); else if (typeof define === 'function' && define.amd) define([], e); else { (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).adapter = e(); } }((() => (function e(t, r, n) { function i(o, s) { if (!r[o]) { if (!t[o]) { const c = typeof require === 'function' && require; if (!s && c) return c(o, !0); if (a) return a(o, !0); const d = new Error(`Cannot find module '${o}'`); throw d.code = 'MODULE_NOT_FOUND', d; } const p = r[o] = { exports: {} }; t[o][0].call(p.exports, ((e) => i(t[o][1][e] || e)), p, p.exports, e, t, r, n); } return r[o].exports; } for (var a = typeof require === 'function' && require, o = 0; o < n.length; o++)i(n[o]); return i; }({
  1: [function (e, t, r) {
    const n = (0, e('./adapter_factory.js').adapterFactory)({ window }); t.exports = n;
  }, { './adapter_factory.js': 2 }],
  2: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.adapterFactory = function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.window; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }; const d = n.log; const p = n.detectBrowser(t); const u = { browserDetails: p, commonShim: c, extractVersion: n.extractVersion, disableLog: n.disableLog, disableWarnings: n.disableWarnings }; switch (p.browser) { case 'chrome': if (!i || !i.shimPeerConnection || !r.shimChrome) return d('Chrome shim is not included in this adapter release.'), u; d('adapter.js shimming chrome.'), u.browserShim = i, i.shimGetUserMedia(t), i.shimMediaStream(t), i.shimPeerConnection(t), i.shimOnTrack(t), i.shimAddTrackRemoveTrack(t), i.shimGetSendersWithDtmf(t), i.shimGetStats(t), i.shimSenderReceiverGetStats(t), i.fixNegotiationNeeded(t), c.shimRTCIceCandidate(t), c.shimConnectionState(t), c.shimMaxMessageSize(t), c.shimSendThrowTypeError(t), c.removeAllowExtmapMixed(t); break; case 'firefox': if (!o || !o.shimPeerConnection || !r.shimFirefox) return d('Firefox shim is not included in this adapter release.'), u; d('adapter.js shimming firefox.'), u.browserShim = o, o.shimGetUserMedia(t), o.shimPeerConnection(t), o.shimOnTrack(t), o.shimRemoveStream(t), o.shimSenderGetStats(t), o.shimReceiverGetStats(t), o.shimRTCDataChannel(t), o.shimAddTransceiver(t), o.shimCreateOffer(t), o.shimCreateAnswer(t), c.shimRTCIceCandidate(t), c.shimConnectionState(t), c.shimMaxMessageSize(t), c.shimSendThrowTypeError(t); break; case 'edge': if (!a || !a.shimPeerConnection || !r.shimEdge) return d('MS edge shim is not included in this adapter release.'), u; d('adapter.js shimming edge.'), u.browserShim = a, a.shimGetUserMedia(t), a.shimGetDisplayMedia(t), a.shimPeerConnection(t), a.shimReplaceTrack(t), c.shimMaxMessageSize(t), c.shimSendThrowTypeError(t); break; case 'safari': if (!s || !r.shimSafari) return d('Safari shim is not included in this adapter release.'), u; d('adapter.js shimming safari.'), u.browserShim = s, s.shimRTCIceServerUrls(t), s.shimCreateOfferLegacy(t), s.shimCallbacksAPI(t), s.shimLocalStreamsAPI(t), s.shimRemoteStreamsAPI(t), s.shimTrackEventTransceiver(t), s.shimGetUserMedia(t), c.shimRTCIceCandidate(t), c.shimMaxMessageSize(t), c.shimSendThrowTypeError(t), c.removeAllowExtmapMixed(t); break; default: d('Unsupported browser!'); } return u; }; var n = d(e('./utils')); var i = d(e('./chrome/chrome_shim')); var a = d(e('./edge/edge_shim')); var o = d(e('./firefox/firefox_shim')); var s = d(e('./safari/safari_shim')); var c = d(e('./common_shim')); function d(e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }
  }, { './chrome/chrome_shim': 3, './common_shim': 6, './edge/edge_shim': 7, './firefox/firefox_shim': 11, './safari/safari_shim': 14, './utils': 15 }],
  3: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const i = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get() { return i.shimGetUserMedia; } }); const a = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get() { return a.shimGetDisplayMedia; } }), r.shimMediaStream = function (e) { e.MediaStream = e.MediaStream || e.webkitMediaStream; }, r.shimOnTrack = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || 'ontrack' in e.RTCPeerConnection.prototype) o.wrapPeerConnectionEvent(e, 'track', ((e) => (e.transceiver || Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } }), e))); else { Object.defineProperty(e.RTCPeerConnection.prototype, 'ontrack', { get() { return this._ontrack; }, set(e) { this._ontrack && this.removeEventListener('track', this._ontrack), this.addEventListener('track', this._ontrack = e); }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const r = this; return this._ontrackpoly || (this._ontrackpoly = function (t) { t.stream.addEventListener('addtrack', ((n) => { let i = void 0; i = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find(((e) => e.track && e.track.id === n.track.id)) : { track: n.track }; const a = new Event('track'); a.track = n.track, a.receiver = i, a.transceiver = { receiver: i }, a.streams = [t.stream], r.dispatchEvent(a); })), t.stream.getTracks().forEach(((n) => { let i = void 0; i = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find(((e) => e.track && e.track.id === n.id)) : { track: n }; const a = new Event('track'); a.track = n, a.receiver = i, a.transceiver = { receiver: i }, a.streams = [t.stream], r.dispatchEvent(a); })); }, this.addEventListener('addstream', this._ontrackpoly)), t.apply(this, arguments); }; } }, r.shimGetSendersWithDtmf = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && !('getSenders' in e.RTCPeerConnection.prototype) && 'createDTMFSender' in e.RTCPeerConnection.prototype) { const t = function (e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && (t.kind === 'audio' ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf; }, _pc: e }; }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice(); }; const r = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, n) { let i = r.apply(this, arguments); return i || (i = t(this, e), this._senders.push(i)), i; }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { i.apply(this, arguments); const t = this._senders.indexOf(e); t !== -1 && this._senders.splice(t, 1); }; } const a = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { const r = this; this._senders = this._senders || [], a.apply(this, [e]), e.getTracks().forEach(((e) => { r._senders.push(t(r, e)); })); }; const o = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { const t = this; this._senders = this._senders || [], o.apply(this, [e]), e.getTracks().forEach(((e) => { const r = t._senders.find(((t) => t.track === e)); r && t._senders.splice(t._senders.indexOf(r), 1); })); }; } else if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && 'getSenders' in e.RTCPeerConnection.prototype && 'createDTMFSender' in e.RTCPeerConnection.prototype && e.RTCRtpSender && !('dtmf' in e.RTCRtpSender.prototype)) { const s = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const e = this; const t = s.apply(this, []); return t.forEach(((t) => t._pc = e)), t; }, Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get() { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf; } }); } }, r.shimGetStats = function (e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const e = this; const r = Array.prototype.slice.call(arguments); const n = r[0]; const i = r[1]; const a = r[2]; if (arguments.length > 0 && typeof n === 'function') return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n !== 'function')) return t.apply(this, []); const o = function (e) { const t = {}; return e.result().forEach(((e) => { const r = { id: e.id, timestamp: e.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[e.type] || e.type }; e.names().forEach(((t) => { r[t] = e.stat(t); })), t[r.id] = r; })), t; }; const s = function (e) { return new Map(Object.keys(e).map(((t) => [t, e[t]]))); }; if (arguments.length >= 2) { const c = function (e) { i(s(o(e))); }; return t.apply(this, [c, n]); } return new Promise(((r, n) => { t.apply(e, [function (e) { r(s(o(e))); }, n]); })).then(i, a); }; }, r.shimSenderReceiverGetStats = function (e) { if (!((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!('getStats' in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = this; const r = t.apply(this, []); return r.forEach(((t) => t._pc = e)), r; }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const e = r.apply(this, arguments); return e._pc = this, e; }), e.RTCRtpSender.prototype.getStats = function () { const e = this; return this._pc.getStats().then(((t) => o.filterStats(t, e.track, !0))); }; } if (!('getStats' in e.RTCRtpReceiver.prototype)) { const i = e.RTCPeerConnection.prototype.getReceivers; i && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = this; const t = i.apply(this, []); return t.forEach(((t) => t._pc = e)), t; }), o.wrapPeerConnectionEvent(e, 'track', ((e) => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function () { const e = this; return this._pc.getStats().then(((t) => o.filterStats(t, e.track, !1))); }; } if (!('getStats' in e.RTCRtpSender.prototype && 'getStats' in e.RTCRtpReceiver.prototype)) return; const a = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const t = arguments[0]; let r = void 0; let n = void 0; let i = void 0; return this.getSenders().forEach(((e) => { e.track === t && (r ? i = !0 : r = e); })), this.getReceivers().forEach(((e) => (e.track === t && (n ? i = !0 : n = e), e.track === t))), i || r && n ? Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError')) : r ? r.getStats() : n ? n.getStats() : Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError')); } return a.apply(this, arguments); }; }, r.shimAddTrackRemoveTrackWithNative = c, r.shimAddTrackRemoveTrack = function (e) { if (!e.RTCPeerConnection) return; const t = o.detectBrowser(e); if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return c(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const e = this; const t = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, t.map(((t) => e._reverseStreams[t.id])); }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { const r = this; if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(((e) => { if (r.getSenders().find(((t) => t.track === e))) throw new DOMException('Track already exists.', 'InvalidAccessError'); })), !this._reverseStreams[t.id]) { const i = new e.MediaStream(t.getTracks()); this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i; } n.apply(this, [t]); }; const i = e.RTCPeerConnection.prototype.removeStream; function a(e, t) { let r = t.sdp; return Object.keys(e._reverseStreams || []).forEach(((t) => { const n = e._reverseStreams[t]; const i = e._streams[n.id]; r = r.replace(new RegExp(i.id, 'g'), n.id); })), new RTCSessionDescription({ type: t.type, sdp: r }); } function d(e, t) { let r = t.sdp; return Object.keys(e._reverseStreams || []).forEach(((t) => { const n = e._reverseStreams[t]; const i = e._streams[n.id]; r = r.replace(new RegExp(n.id, 'g'), i.id); })), new RTCSessionDescription({ type: t.type, sdp: r }); } e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]; }, e.RTCPeerConnection.prototype.addTrack = function (t, r) { const n = this; if (this.signalingState === 'closed') throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError'); const i = [].slice.call(arguments, 1); if (i.length !== 1 || !i[0].getTracks().find(((e) => e === t))) throw new DOMException('The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.', 'NotSupportedError'); const a = this.getSenders().find(((e) => e.track === t)); if (a) throw new DOMException('Track already exists.', 'InvalidAccessError'); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const o = this._streams[r.id]; if (o) o.addTrack(t), Promise.resolve().then((() => { n.dispatchEvent(new Event('negotiationneeded')); })); else { const s = new e.MediaStream([t]); this._streams[r.id] = s, this._reverseStreams[s.id] = r, this.addStream(s); } return this.getSenders().find(((e) => e.track === t)); }, ['createOffer', 'createAnswer'].forEach(((t) => { const r = e.RTCPeerConnection.prototype[t]; const n = s({}, t, (function () { const e = this; const t = arguments; const n = arguments.length && typeof arguments[0] === 'function'; return n ? r.apply(this, [function (r) { const n = a(e, r); t[0].apply(null, [n]); }, function (e) { t[1] && t[1].apply(null, e); }, arguments[2]]) : r.apply(this, arguments).then(((t) => a(e, t))); })); e.RTCPeerConnection.prototype[t] = n[t]; })); const p = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return arguments.length && arguments[0].type ? (arguments[0] = d(this, arguments[0]), p.apply(this, arguments)) : p.apply(this, arguments); }; const u = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, 'localDescription'); Object.defineProperty(e.RTCPeerConnection.prototype, 'localDescription', { get() { const e = u.get.apply(this); return e.type === '' ? e : a(this, e); } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { const t = this; if (this.signalingState === 'closed') throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError'); if (!e._pc) throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.', 'TypeError'); if (!(e._pc === this)) throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError'); this._streams = this._streams || {}; let r = void 0; Object.keys(this._streams).forEach(((n) => { t._streams[n].getTracks().find(((t) => e.track === t)) && (r = t._streams[n]); })), r && (r.getTracks().length === 1 ? this.removeStream(this._reverseStreams[r.id]) : r.removeTrack(e.track), this.dispatchEvent(new Event('negotiationneeded'))); }; }, r.shimPeerConnection = function (e) { const t = o.detectBrowser(e); !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection); if (!e.RTCPeerConnection) return; t.version < 53 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(((t) => { const r = e.RTCPeerConnection.prototype[t]; const n = s({}, t, (function () { return arguments[0] = new (t === 'addIceCandidate' ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments); })); e.RTCPeerConnection.prototype[t] = n[t]; })); const r = e.RTCPeerConnection.prototype.addIceCandidate; e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? t.version < 78 && arguments[0] && arguments[0].candidate === '' ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()); }; }, r.fixNegotiationNeeded = function (e) { o.wrapPeerConnectionEvent(e, 'negotiationneeded', ((e) => { if (e.target.signalingState === 'stable') return e; })); }; var o = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils.js'))); function s(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e; } function c(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { const e = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(((t) => e._shimmedLocalStreams[t][0])); }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { if (!r) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const n = t.apply(this, arguments); return this._shimmedLocalStreams[r.id] ? this._shimmedLocalStreams[r.id].indexOf(n) === -1 && this._shimmedLocalStreams[r.id].push(n) : this._shimmedLocalStreams[r.id] = [r, n], n; }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { const t = this; this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(((e) => { if (t.getSenders().find(((t) => t.track === e))) throw new DOMException('Track already exists.', 'InvalidAccessError'); })); const n = this.getSenders(); r.apply(this, arguments); const i = this.getSenders().filter(((e) => n.indexOf(e) === -1)); this._shimmedLocalStreams[e.id] = [e].concat(i); }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments); }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { const t = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(((r) => { const n = t._shimmedLocalStreams[r].indexOf(e); n !== -1 && t._shimmedLocalStreams[r].splice(n, 1), t._shimmedLocalStreams[r].length === 1 && delete t._shimmedLocalStreams[r]; })), i.apply(this, arguments); }; }
  }, { '../utils.js': 15, './getdisplaymedia': 4, './getusermedia': 5 }],
  4: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e, t) { if (e.navigator.mediaDevices && 'getDisplayMedia' in e.navigator.mediaDevices) return; if (!e.navigator.mediaDevices) return; if (typeof t !== 'function') return void console.error('shimGetDisplayMedia: getSourceId argument is not a function'); e.navigator.mediaDevices.getDisplayMedia = function (r) { return t(r).then(((t) => { const n = r.video && r.video.width; const i = r.video && r.video.height; const a = r.video && r.video.frameRate; return r.video = { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: t, maxFrameRate: a || 3 } }, n && (r.video.mandatory.maxWidth = n), i && (r.video.mandatory.maxHeight = i), e.navigator.mediaDevices.getUserMedia(r); })); }; };
  }, {}],
  5: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimGetUserMedia = function (e) { const t = e && e.navigator; if (!t.mediaDevices) return; const r = i.detectBrowser(e); const o = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || e.mandatory || e.optional) return e; const t = {}; return Object.keys(e).forEach(((r) => { if (r !== 'require' && r !== 'advanced' && r !== 'mediaSource') { const i = n(e[r]) === 'object' ? e[r] : { ideal: e[r] }; void 0 !== i.exact && typeof i.exact === 'number' && (i.min = i.max = i.exact); const a = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t; }; if (void 0 !== i.ideal) { t.optional = t.optional || []; let o = {}; typeof i.ideal === 'number' ? (o[a('min', r)] = i.ideal, t.optional.push(o), (o = {})[a('max', r)] = i.ideal, t.optional.push(o)) : (o[a('', r)] = i.ideal, t.optional.push(o)); } void 0 !== i.exact && typeof i.exact !== 'number' ? (t.mandatory = t.mandatory || {}, t.mandatory[a('', r)] = i.exact) : ['min', 'max'].forEach(((e) => { void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[a(e, r)] = i[e]); })); } })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t; }; const s = function (e, i) { if (r.version >= 61) return i(e); if ((e = JSON.parse(JSON.stringify(e))) && n(e.audio) === 'object') { const s = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]); }; s((e = JSON.parse(JSON.stringify(e))).audio, 'autoGainControl', 'googAutoGainControl'), s(e.audio, 'noiseSuppression', 'googNoiseSuppression'), e.audio = o(e.audio); } if (e && n(e.video) === 'object') { let c = e.video.facingMode; c = c && ((void 0 === c ? 'undefined' : n(c)) === 'object' ? c : { ideal: c }); const d = r.version < 66; if (c && (c.exact === 'user' || c.exact === 'environment' || c.ideal === 'user' || c.ideal === 'environment') && (!t.mediaDevices.getSupportedConstraints || !t.mediaDevices.getSupportedConstraints().facingMode || d)) { delete e.video.facingMode; let p = void 0; if (c.exact === 'environment' || c.ideal === 'environment' ? p = ['back', 'rear'] : c.exact !== 'user' && c.ideal !== 'user' || (p = ['front']), p) return t.mediaDevices.enumerateDevices().then(((t) => { let r = (t = t.filter(((e) => e.kind === 'videoinput'))).find(((e) => p.some(((t) => e.label.toLowerCase().includes(t))))); return !r && t.length && p.includes('back') && (r = t[t.length - 1]), r && (e.video.deviceId = c.exact ? { exact: r.deviceId } : { ideal: r.deviceId }), e.video = o(e.video), a(`chrome: ${JSON.stringify(e)}`), i(e); })); } e.video = o(e.video); } return a(`chrome: ${JSON.stringify(e)}`), i(e); }; const c = function (e) { return r.version >= 64 ? e : { name: { PermissionDeniedError: 'NotAllowedError', PermissionDismissedError: 'NotAllowedError', InvalidStateError: 'NotAllowedError', DevicesNotFoundError: 'NotFoundError', ConstraintNotSatisfiedError: 'OverconstrainedError', TrackStartError: 'NotReadableError', MediaDeviceFailedDueToShutdown: 'NotAllowedError', MediaDeviceKillSwitchOn: 'NotAllowedError', TabCaptureError: 'AbortError', ScreenCaptureError: 'AbortError', DeviceCaptureError: 'AbortError' }[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString() { return this.name + (this.message && ': ') + this.message; } }; }; if (t.getUserMedia = function (e, r, n) { s(e, ((e) => { t.webkitGetUserMedia(e, r, ((e) => { n && n(c(e)); })); })); }, t.mediaDevices.getUserMedia) { const d = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (e) { return s(e, ((e) => d(e).then(((t) => { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(((e) => { e.stop(); })), new DOMException('', 'NotFoundError'); return t; }), ((e) => Promise.reject(c(e)))))); }; } }; var i = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils.js'))); var a = i.log;
  }, { '../utils.js': 15 }],
  6: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimRTCIceCandidate = function (e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && 'foundation' in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.candidate && e.candidate.indexOf('a=') === 0 && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { const r = new t(e); const i = o.default.parseCandidate(e.candidate); const a = Object.assign(r, i); return a.toJSON = function () { return { candidate: a.candidate, sdpMid: a.sdpMid, sdpMLineIndex: a.sdpMLineIndex, usernameFragment: a.usernameFragment }; }, a; } return new t(e); }, e.RTCIceCandidate.prototype = t.prototype, s.wrapPeerConnectionEvent(e, 'icecandidate', ((t) => (t.candidate && Object.defineProperty(t, 'candidate', { value: new e.RTCIceCandidate(t.candidate), writable: 'false' }), t))); }, r.shimMaxMessageSize = function (e) { if (!e.RTCPeerConnection) return; const t = s.detectBrowser(e); 'sctp' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'sctp', { get() { return void 0 === this._sctp ? null : this._sctp; } }); const r = function (e) { if (!e || !e.sdp) return !1; const t = o.default.splitSections(e.sdp); return t.shift(), t.some(((e) => { const t = o.default.parseMLine(e); return t && t.kind === 'application' && t.protocol.indexOf('SCTP') !== -1; })); }; const n = function (e) { const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (t === null || t.length < 2) return -1; const r = parseInt(t[1], 10); return r != r ? -1 : r; }; const i = function (e) { let r = 65536; return t.browser === 'firefox' && (r = t.version < 57 ? e === -1 ? 16384 : 2147483637 : t.version < 60 ? t.version === 57 ? 65535 : 65536 : 2147483637), r; }; const a = function (e, r) { let n = 65536; t.browser === 'firefox' && t.version === 57 && (n = 65535); const i = o.default.matchPrefix(e.sdp, 'a=max-message-size:'); return i.length > 0 ? n = parseInt(i[0].substr(19), 10) : t.browser === 'firefox' && r !== -1 && (n = 2147483637), n; }; const c = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === 'chrome' && t.version >= 76) { const e = this.getConfiguration(); const o = e.sdpSemantics; o === 'plan-b' && Object.defineProperty(this, 'sctp', { get() { return void 0 === this._sctp ? null : this._sctp; }, enumerable: !0, configurable: !0 }); } if (r(arguments[0])) { const s = n(arguments[0]); const d = i(s); const p = a(arguments[0], s); let u = void 0; u = d === 0 && p === 0 ? Number.POSITIVE_INFINITY : d === 0 || p === 0 ? Math.max(d, p) : Math.min(d, p); const f = {}; Object.defineProperty(f, 'maxMessageSize', { get() { return u; } }), this._sctp = f; } return c.apply(this, arguments); }; }, r.shimSendThrowTypeError = function (e) { if (!(e.RTCPeerConnection && 'createDataChannel' in e.RTCPeerConnection.prototype)) return; function t(e, t) { const r = e.send; e.send = function () { const n = arguments[0]; const i = n.length || n.size || n.byteLength; if (e.readyState === 'open' && t.sctp && i > t.sctp.maxMessageSize) throw new TypeError(`Message too large (can send a maximum of ${t.sctp.maxMessageSize} bytes)`); return r.apply(e, arguments); }; } const r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const e = r.apply(this, arguments); return t(e, this), e; }, s.wrapPeerConnectionEvent(e, 'datachannel', ((e) => (t(e.channel, e.target), e))); }, r.shimConnectionState = function (e) { if (!e.RTCPeerConnection || 'connectionState' in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, 'connectionState', { get() { return { completed: 'connected', checking: 'connecting' }[this.iceConnectionState] || this.iceConnectionState; }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, 'onconnectionstatechange', { get() { return this._onconnectionstatechange || null; }, set(e) { this._onconnectionstatechange && (this.removeEventListener('connectionstatechange', this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener('connectionstatechange', this._onconnectionstatechange = e); }, enumerable: !0, configurable: !0 }), ['setLocalDescription', 'setRemoteDescription'].forEach(((e) => { const r = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = function (e) { const t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; const r = new Event('connectionstatechange', e); t.dispatchEvent(r); } return e; }, this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly)), r.apply(this, arguments); }; })); }, r.removeAllowExtmapMixed = function (e) { if (!e.RTCPeerConnection) return; const t = s.detectBrowser(e); if (t.browser === 'chrome' && t.version >= 71) return; const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (e) { return e && e.sdp && e.sdp.indexOf('\na=extmap-allow-mixed') !== -1 && (e.sdp = e.sdp.split('\n').filter(((e) => e.trim() !== 'a=extmap-allow-mixed')).join('\n')), r.apply(this, arguments); }; }; let i; const a = e('sdp'); var o = (i = a) && i.__esModule ? i : { default: i }; var s = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('./utils')));
  }, { './utils': 15, sdp: 17 }],
  7: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; const n = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get() { return n.shimGetUserMedia; } }); const i = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get() { return i.shimGetDisplayMedia; } }), r.shimPeerConnection = function (e) { const t = o.detectBrowser(e); if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function (e) { return e; }), e.RTCSessionDescription || (e.RTCSessionDescription = function (e) { return e; }), t.version < 15025)) { const r = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, 'enabled'); Object.defineProperty(e.MediaStreamTrack.prototype, 'enabled', { set(e) { r.set.call(this, e); const t = new Event('enabled'); t.enabled = e, this.dispatchEvent(t); } }); } !e.RTCRtpSender || 'dtmf' in e.RTCRtpSender.prototype || Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get() { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === 'video' && (this._dtmf = null)), this._dtmf; } }); e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender); const n = (0, d.default)(e, t.version); e.RTCPeerConnection = function (e) { return e && e.iceServers && (e.iceServers = (0, s.filterIceServers)(e.iceServers, t.version), o.log('ICE servers after filtering:', e.iceServers)), new n(e); }, e.RTCPeerConnection.prototype = n.prototype; }, r.shimReplaceTrack = function (e) { !e.RTCRtpSender || 'replaceTrack' in e.RTCRtpSender.prototype || (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack); }; let a; var o = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils'))); var s = e('./filtericeservers'); const c = e('rtcpeerconnection-shim'); var d = (a = c) && a.__esModule ? a : { default: a };
  }, { '../utils': 15, './filtericeservers': 8, './getdisplaymedia': 9, './getusermedia': 10, 'rtcpeerconnection-shim': 16 }],
  8: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.filterIceServers = function (e, t) { let r = !1; return (e = JSON.parse(JSON.stringify(e))).filter(((e) => { if (e && (e.urls || e.url)) { let t = e.urls || e.url; e.url && !e.urls && n.deprecated('RTCIceServer.url', 'RTCIceServer.urls'); const i = typeof t === 'string'; return i && (t = [t]), t = t.filter(((e) => { if (e.indexOf('stun:') === 0) return !1; const t = e.startsWith('turn') && !e.startsWith('turn:[') && e.includes('transport=udp'); return t && !r ? (r = !0, !0) : t && !r; })), delete e.url, e.urls = i ? t[0] : t, !!t.length; } })); }; var n = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils')));
  }, { '../utils': 15 }],
  9: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e) { if (!('getDisplayMedia' in e.navigator)) return; if (!e.navigator.mediaDevices) return; if (e.navigator.mediaDevices && 'getDisplayMedia' in e.navigator.mediaDevices) return; e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator); };
  }, {}],
  10: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetUserMedia = function (e) { const t = e && e.navigator; const r = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (e) { return r(e).catch(((e) => Promise.reject(function (e) { return { name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name, message: e.message, constraint: e.constraint, toString() { return this.name; } }; }(e)))); }; };
  }, {}],
  11: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const i = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get() { return i.shimGetUserMedia; } }); const a = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get() { return a.shimGetDisplayMedia; } }), r.shimOnTrack = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCTrackEvent && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get() { return { receiver: this.receiver }; } }); }, r.shimPeerConnection = function (e) { const t = o.detectBrowser(e); if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection); t.version < 53 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(((t) => { const r = e.RTCPeerConnection.prototype[t]; const n = (function (e, t, r) { t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r; return e; }({}, t, (function () { return arguments[0] = new (t === 'addIceCandidate' ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments); }))); e.RTCPeerConnection.prototype[t] = n[t]; })); if (t.version < 68) { const r = e.RTCPeerConnection.prototype.addIceCandidate; e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? arguments[0] && arguments[0].candidate === '' ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()); }; } const i = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; const a = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const e = Array.prototype.slice.call(arguments); const r = e[0]; const n = e[1]; const o = e[2]; return a.apply(this, [r || null]).then(((e) => { if (t.version < 53 && !n) try { e.forEach(((e) => { e.type = i[e.type] || e.type; })); } catch (t) { if (t.name !== 'TypeError') throw t; e.forEach(((t, r) => { e.set(r, { ...t, type: i[t.type] || t.type }); })); } return e; })).then(n, o); }; }, r.shimSenderGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && 'getStats' in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = this; const r = t.apply(this, []); return r.forEach(((t) => t._pc = e)), r; }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const e = r.apply(this, arguments); return e._pc = this, e; }); e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map()); }; }, r.shimReceiverGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && 'getStats' in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = this; const r = t.apply(this, []); return r.forEach(((t) => t._pc = e)), r; }); o.wrapPeerConnectionEvent(e, 'track', ((e) => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track); }; }, r.shimRemoveStream = function (e) { if (!e.RTCPeerConnection || 'removeStream' in e.RTCPeerConnection.prototype) return; e.RTCPeerConnection.prototype.removeStream = function (e) { const t = this; o.deprecated('removeStream', 'removeTrack'), this.getSenders().forEach(((r) => { r.track && e.getTracks().includes(r.track) && t.removeTrack(r); })); }; }, r.shimRTCDataChannel = function (e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel); }, r.shimAddTransceiver = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const e = arguments[1]; const r = e && 'sendEncodings' in e; r && e.sendEncodings.forEach(((e) => { if ('rid' in e) { if (!/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError('Invalid RID value provided.'); } if ('scaleResolutionDownBy' in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError('scale_resolution_down_by must be >= 1.0'); if ('maxFramerate' in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError('max_framerate must be >= 0.0'); })); const n = t.apply(this, arguments); if (r) { const i = n.sender; const a = i.getParameters(); 'encodings' in a || (a.encodings = e.sendEncodings, this.setParametersPromises.push(i.setParameters(a).catch((() => { })))); } return n; }); }, r.shimCreateOffer = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { const e = this; const r = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(e, r))).finally((() => { e.setParametersPromises = []; })) : t.apply(this, arguments); }; }, r.shimCreateAnswer = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { const e = this; const r = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(e, r))).finally((() => { e.setParametersPromises = []; })) : t.apply(this, arguments); }; }; var o = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils')));
  }, { '../utils': 15, './getdisplaymedia': 12, './getusermedia': 13 }],
  12: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e, t) { if (e.navigator.mediaDevices && 'getDisplayMedia' in e.navigator.mediaDevices) return; if (!e.navigator.mediaDevices) return; e.navigator.mediaDevices.getDisplayMedia = function (r) { if (!r || !r.video) { const n = new DOMException('getDisplayMedia without video constraints is undefined'); return n.name = 'NotFoundError', n.code = 8, Promise.reject(n); } return !0 === r.video ? r.video = { mediaSource: t } : r.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(r); }; };
  }, {}],
  13: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimGetUserMedia = function (e) { const t = i.detectBrowser(e); const r = e && e.navigator; const a = e && e.MediaStreamTrack; if (r.getUserMedia = function (e, t, n) { i.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia'), r.mediaDevices.getUserMedia(e).then(t, n); }, !(t.version > 55 && 'autoGainControl' in r.mediaDevices.getSupportedConstraints())) { const o = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]); }; const s = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (e) { return (void 0 === e ? 'undefined' : n(e)) === 'object' && n(e.audio) === 'object' && (e = JSON.parse(JSON.stringify(e)), o(e.audio, 'autoGainControl', 'mozAutoGainControl'), o(e.audio, 'noiseSuppression', 'mozNoiseSuppression')), s(e); }, a && a.prototype.getSettings) { const c = a.prototype.getSettings; a.prototype.getSettings = function () { const e = c.apply(this, arguments); return o(e, 'mozAutoGainControl', 'autoGainControl'), o(e, 'mozNoiseSuppression', 'noiseSuppression'), e; }; } if (a && a.prototype.applyConstraints) { const d = a.prototype.applyConstraints; a.prototype.applyConstraints = function (e) { return this.kind === 'audio' && (void 0 === e ? 'undefined' : n(e)) === 'object' && (e = JSON.parse(JSON.stringify(e)), o(e, 'autoGainControl', 'mozAutoGainControl'), o(e, 'noiseSuppression', 'mozNoiseSuppression')), d.apply(this, [e]); }; } } }; var i = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils')));
  }, { '../utils': 15 }],
  14: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimLocalStreamsAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; 'getLocalStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams; }); if (!('addStream' in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { const r = this; this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(((n) => t.call(r, n, e))), e.getVideoTracks().forEach(((n) => t.call(r, n, e))); }, e.RTCPeerConnection.prototype.addTrack = function (e) { const r = arguments[1]; return r && (this._localStreams ? this._localStreams.includes(r) || this._localStreams.push(r) : this._localStreams = [r]), t.apply(this, arguments); }; } 'removeStream' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { const t = this; this._localStreams || (this._localStreams = []); const r = this._localStreams.indexOf(e); if (r !== -1) { this._localStreams.splice(r, 1); const n = e.getTracks(); this.getSenders().forEach(((e) => { n.includes(e.track) && t.removeTrack(e); })); } }); }, r.shimRemoteStreamsAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; 'getRemoteStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : []; }); if (!('onaddstream' in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, 'onaddstream', { get() { return this._onaddstream; }, set(e) { const t = this; this._onaddstream && (this.removeEventListener('addstream', this._onaddstream), this.removeEventListener('track', this._onaddstreampoly)), this.addEventListener('addstream', this._onaddstream = e), this.addEventListener('track', this._onaddstreampoly = function (e) { e.streams.forEach(((e) => { if (t._remoteStreams || (t._remoteStreams = []), !t._remoteStreams.includes(e)) { t._remoteStreams.push(e); const r = new Event('addstream'); r.stream = e, t.dispatchEvent(r); } })); }); } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const e = this; return this._onaddstreampoly || this.addEventListener('track', this._onaddstreampoly = function (t) { t.streams.forEach(((t) => { if (e._remoteStreams || (e._remoteStreams = []), !(e._remoteStreams.indexOf(t) >= 0)) { e._remoteStreams.push(t); const r = new Event('addstream'); r.stream = t, e.dispatchEvent(r); } })); }), t.apply(e, arguments); }; } }, r.shimCallbacksAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype; const r = t.createOffer; const i = t.createAnswer; const a = t.setLocalDescription; const o = t.setRemoteDescription; const s = t.addIceCandidate; t.createOffer = function (e, t) { const n = arguments.length >= 2 ? arguments[2] : arguments[0]; const i = r.apply(this, [n]); return t ? (i.then(e, t), Promise.resolve()) : i; }, t.createAnswer = function (e, t) { const r = arguments.length >= 2 ? arguments[2] : arguments[0]; const n = i.apply(this, [r]); return t ? (n.then(e, t), Promise.resolve()) : n; }; let c = function (e, t, r) { const n = a.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n; }; t.setLocalDescription = c, c = function (e, t, r) { const n = o.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n; }, t.setRemoteDescription = c, c = function (e, t, r) { const n = s.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n; }, t.addIceCandidate = c; }, r.shimGetUserMedia = function (e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices; const n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = function (e) { return n(a(e)); }; } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, r, n) { t.mediaDevices.getUserMedia(e).then(r, n); }); }, r.shimConstraints = a, r.shimRTCIceServerUrls = function (e) { const t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, r) { if (e && e.iceServers) { for (var n = [], a = 0; a < e.iceServers.length; a++) { let o = e.iceServers[a]; !o.hasOwnProperty('urls') && o.hasOwnProperty('url') ? (i.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (o = JSON.parse(JSON.stringify(o))).urls = o.url, delete o.url, n.push(o)) : n.push(e.iceServers[a]); } e.iceServers = n; } return new t(e, r); }, e.RTCPeerConnection.prototype = t.prototype, 'generateCertificate' in e.RTCPeerConnection && Object.defineProperty(e.RTCPeerConnection, 'generateCertificate', { get() { return t.generateCertificate; } }); }, r.shimTrackEventTransceiver = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCTrackEvent && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get() { return { receiver: this.receiver }; } }); }, r.shimCreateOfferLegacy = function (e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); const r = this.getTransceivers().find(((e) => e.receiver.track.kind === 'audio')); !1 === e.offerToReceiveAudio && r ? r.direction === 'sendrecv' ? r.setDirection ? r.setDirection('sendonly') : r.direction = 'sendonly' : r.direction === 'recvonly' && (r.setDirection ? r.setDirection('inactive') : r.direction = 'inactive') : !0 !== e.offerToReceiveAudio || r || this.addTransceiver('audio'), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); const n = this.getTransceivers().find(((e) => e.receiver.track.kind === 'video')); !1 === e.offerToReceiveVideo && n ? n.direction === 'sendrecv' ? n.setDirection ? n.setDirection('sendonly') : n.direction = 'sendonly' : n.direction === 'recvonly' && (n.setDirection ? n.setDirection('inactive') : n.direction = 'inactive') : !0 !== e.offerToReceiveVideo || n || this.addTransceiver('video'); } return t.apply(this, arguments); }; }; var i = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils'))); function a(e) { return e && void 0 !== e.video ? ({ ...e, video: i.compactObject(e.video) }) : e; }
  }, { '../utils': 15 }],
  15: [function (e, t, r) {
    Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.extractVersion = o, r.wrapPeerConnectionEvent = function (e, t, r) { if (!e.RTCPeerConnection) return; const n = e.RTCPeerConnection.prototype; const i = n.addEventListener; n.addEventListener = function (e, n) { if (e !== t) return i.apply(this, arguments); const a = function (e) { const t = r(e); t && n(t); }; return this._eventMap = this._eventMap || {}, this._eventMap[n] = a, i.apply(this, [e, a]); }; const a = n.removeEventListener; n.removeEventListener = function (e, r) { if (e !== t || !this._eventMap || !this._eventMap[r]) return a.apply(this, arguments); const n = this._eventMap[r]; return delete this._eventMap[r], a.apply(this, [e, n]); }, Object.defineProperty(n, `on${t}`, { get() { return this[`_on${t}`]; }, set(e) { this[`_on${t}`] && (this.removeEventListener(t, this[`_on${t}`]), delete this[`_on${t}`]), e && this.addEventListener(t, this[`_on${t}`] = e); }, enumerable: !0, configurable: !0 }); }, r.disableLog = function (e) { if (typeof e !== 'boolean') return new Error(`Argument type: ${void 0 === e ? 'undefined' : n(e)}. Please use a boolean.`); return i = e, e ? 'adapter.js logging disabled' : 'adapter.js logging enabled'; }, r.disableWarnings = function (e) { if (typeof e !== 'boolean') return new Error(`Argument type: ${void 0 === e ? 'undefined' : n(e)}. Please use a boolean.`); return a = !e, `adapter.js deprecation warnings ${e ? 'disabled' : 'enabled'}`; }, r.log = function () { if ((typeof window === 'undefined' ? 'undefined' : n(window)) === 'object') { if (i) return; typeof console !== 'undefined' && typeof console.log === 'function' && console.log.apply(console, arguments); } }, r.deprecated = function (e, t) { if (!a) return; console.warn(`${e} is deprecated, please use ${t} instead.`); }, r.detectBrowser = function (e) { const t = e.navigator; const r = { browser: null, version: null }; if (void 0 === e || !e.navigator) return r.browser = 'Not a browser.', r; if (t.mozGetUserMedia) r.browser = 'firefox', r.version = o(t.userAgent, /Firefox\/(\d+)\./, 1); else if (t.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) r.browser = 'chrome', r.version = o(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/)) r.browser = 'edge', r.version = o(t.userAgent, /Edge\/(\d+).(\d+)$/, 2); else { if (!e.RTCPeerConnection || !t.userAgent.match(/AppleWebKit\/(\d+)\./)) return r.browser = 'Not a supported browser.', r; r.browser = 'safari', r.version = o(t.userAgent, /AppleWebKit\/(\d+)\./, 1), r.supportsUnifiedPlan = e.RTCRtpTransceiver && 'currentDirection' in e.RTCRtpTransceiver.prototype; } return r; }, r.compactObject = function e(t) { if (!s(t)) return t; return Object.keys(t).reduce(((r, n) => { const i = s(t[n]); const a = i ? e(t[n]) : t[n]; const o = i && !Object.keys(a).length; return void 0 === a || o ? r : Object.assign(r, (function (e, t, r) { t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r; return e; }({}, n, a))); }), {}); }, r.walkStats = c, r.filterStats = function (e, t, r) {
      const n = r ? 'outbound-rtp' : 'inbound-rtp'; const
        i = new Map(); if (t === null) return i; const a = []; return e.forEach(((e) => { e.type === 'track' && e.trackIdentifier === t.id && a.push(e); })), a.forEach(((t) => { e.forEach(((r) => { r.type === n && r.trackId === t.id && c(e, r, i); })); })), i;
    }; var i = !0; var a = !0; function o(e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10); } function s(e) { return Object.prototype.toString.call(e) === '[object Object]'; } function c(e, t, r) { t && !r.has(t.id) && (r.set(t.id, t), Object.keys(t).forEach(((n) => { n.endsWith('Id') ? c(e, e.get(t[n]), r) : n.endsWith('Ids') && t[n].forEach(((t) => { c(e, e.get(t), r); })); }))); }
  }, {}],
  16: [function (e, t, r) {
    const n = e('sdp'); function i(e, t, r, i, a) { let o = n.writeRtpDescription(e.kind, t); if (o += n.writeIceParameters(e.iceGatherer.getLocalParameters()), o += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === 'offer' ? 'actpass' : a || 'active'), o += `a=mid:${e.mid}\r\n`, e.rtpSender && e.rtpReceiver ? o += 'a=sendrecv\r\n' : e.rtpSender ? o += 'a=sendonly\r\n' : e.rtpReceiver ? o += 'a=recvonly\r\n' : o += 'a=inactive\r\n', e.rtpSender) { const s = e.rtpSender._initialTrackId || e.rtpSender.track.id; e.rtpSender._initialTrackId = s; const c = `msid:${i ? i.id : '-'} ${s}\r\n`; o += `a=${c}`, o += `a=ssrc:${e.sendEncodingParameters[0].ssrc} ${c}`, e.sendEncodingParameters[0].rtx && (o += `a=ssrc:${e.sendEncodingParameters[0].rtx.ssrc} ${c}`, o += `a=ssrc-group:FID ${e.sendEncodingParameters[0].ssrc} ${e.sendEncodingParameters[0].rtx.ssrc}\r\n`); } return o += `a=ssrc:${e.sendEncodingParameters[0].ssrc} cname:${n.localCName}\r\n`, e.rtpSender && e.sendEncodingParameters[0].rtx && (o += `a=ssrc:${e.sendEncodingParameters[0].rtx.ssrc} cname:${n.localCName}\r\n`), o; } function a(e, t) { const r = { codecs: [], headerExtensions: [], fecMechanisms: [] }; const n = function (e, t) { e = parseInt(e, 10); for (let r = 0; r < t.length; r++) if (t[r].payloadType === e || t[r].preferredPayloadType === e) return t[r]; }; const i = function (e, t, r, i) { const a = n(e.parameters.apt, r); const o = n(t.parameters.apt, i); return a && o && a.name.toLowerCase() === o.name.toLowerCase(); }; return e.codecs.forEach(((n) => { for (let a = 0; a < t.codecs.length; a++) { let o = t.codecs[a]; if (n.name.toLowerCase() === o.name.toLowerCase() && n.clockRate === o.clockRate) { if (n.name.toLowerCase() === 'rtx' && n.parameters && o.parameters.apt && !i(n, o, e.codecs, t.codecs)) continue; (o = JSON.parse(JSON.stringify(o))).numChannels = Math.min(n.numChannels, o.numChannels), r.codecs.push(o), o.rtcpFeedback = o.rtcpFeedback.filter(((e) => { for (let t = 0; t < n.rtcpFeedback.length; t++) if (n.rtcpFeedback[t].type === e.type && n.rtcpFeedback[t].parameter === e.parameter) return !0; return !1; })); break; } } })), e.headerExtensions.forEach(((e) => { for (let n = 0; n < t.headerExtensions.length; n++) { const i = t.headerExtensions[n]; if (e.uri === i.uri) { r.headerExtensions.push(i); break; } } })), r; } function o(e, t, r) { return { offer: { setLocalDescription: ['stable', 'have-local-offer'], setRemoteDescription: ['stable', 'have-remote-offer'] }, answer: { setLocalDescription: ['have-remote-offer', 'have-local-pranswer'], setRemoteDescription: ['have-local-offer', 'have-remote-pranswer'] } }[t][e].indexOf(r) !== -1; } function s(e, t) { const r = e.getRemoteCandidates().find(((e) => t.foundation === e.foundation && t.ip === e.ip && t.port === e.port && t.priority === e.priority && t.protocol === e.protocol && t.type === e.type)); return r || e.addRemoteCandidate(t), !r; } function c(e, t) { const r = new Error(t); return r.name = e, r.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e], r; } t.exports = function (e, t) { function r(t, r) { r.addTrack(t), r.dispatchEvent(new e.MediaStreamTrackEvent('addtrack', { track: t })); } function d(t, r, n, i) { const a = new Event('track'); a.track = r, a.receiver = n, a.transceiver = { receiver: n }, a.streams = i, e.setTimeout((() => { t._dispatchEvent('track', a); })); } const p = function (r) { const i = this; const a = document.createDocumentFragment(); if (['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(((e) => { i[e] = a[e].bind(a); })), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = 'stable', this.iceConnectionState = 'new', this.connectionState = 'new', this.iceGatheringState = 'new', r = JSON.parse(JSON.stringify(r || {})), this.usingBundle = r.bundlePolicy === 'max-bundle', r.rtcpMuxPolicy === 'negotiate') throw c('NotSupportedError', 'rtcpMuxPolicy \'negotiate\' is not supported'); switch (r.rtcpMuxPolicy || (r.rtcpMuxPolicy = 'require'), r.iceTransportPolicy) { case 'all': case 'relay': break; default: r.iceTransportPolicy = 'all'; } switch (r.bundlePolicy) { case 'balanced': case 'max-compat': case 'max-bundle': break; default: r.bundlePolicy = 'balanced'; } if (r.iceServers = (function (e, t) { let r = !1; return (e = JSON.parse(JSON.stringify(e))).filter(((e) => { if (e && (e.urls || e.url)) { let n = e.urls || e.url; e.url && !e.urls && console.warn('RTCIceServer.url is deprecated! Use urls instead.'); const i = typeof n === 'string'; return i && (n = [n]), n = n.filter(((e) => (e.indexOf('turn:') === 0 && e.indexOf('transport=udp') !== -1 && e.indexOf('turn:[') === -1 && !r ? (r = !0, !0) : e.indexOf('stun:') === 0 && t >= 14393 && e.indexOf('?transport=udp') === -1))), delete e.url, e.urls = i ? n[0] : n, !!n.length; } })); }(r.iceServers || [], t)), this._iceGatherers = [], r.iceCandidatePoolSize) for (let o = r.iceCandidatePoolSize; o > 0; o--) this._iceGatherers.push(new e.RTCIceGatherer({ iceServers: r.iceServers, gatherPolicy: r.iceTransportPolicy })); else r.iceCandidatePoolSize = 0; this._config = r, this.transceivers = [], this._sdpSessionId = n.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1; }; Object.defineProperty(p.prototype, 'localDescription', { configurable: !0, get() { return this._localDescription; } }), Object.defineProperty(p.prototype, 'remoteDescription', { configurable: !0, get() { return this._remoteDescription; } }), p.prototype.onicecandidate = null, p.prototype.onaddstream = null, p.prototype.ontrack = null, p.prototype.onremovestream = null, p.prototype.onsignalingstatechange = null, p.prototype.oniceconnectionstatechange = null, p.prototype.onconnectionstatechange = null, p.prototype.onicegatheringstatechange = null, p.prototype.onnegotiationneeded = null, p.prototype.ondatachannel = null, p.prototype._dispatchEvent = function (e, t) { this._isClosed || (this.dispatchEvent(t), typeof this[`on${e}`] === 'function' && this[`on${e}`](t)); }, p.prototype._emitGatheringStateChange = function () { const e = new Event('icegatheringstatechange'); this._dispatchEvent('icegatheringstatechange', e); }, p.prototype.getConfiguration = function () { return this._config; }, p.prototype.getLocalStreams = function () { return this.localStreams; }, p.prototype.getRemoteStreams = function () { return this.remoteStreams; }, p.prototype._createTransceiver = function (e, t) { const r = this.transceivers.length > 0; const n = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: e, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && r) n.iceTransport = this.transceivers[0].iceTransport, n.dtlsTransport = this.transceivers[0].dtlsTransport; else { const i = this._createIceAndDtlsTransports(); n.iceTransport = i.iceTransport, n.dtlsTransport = i.dtlsTransport; } return t || this.transceivers.push(n), n; }, p.prototype.addTrack = function (t, r) { if (this._isClosed) throw c('InvalidStateError', 'Attempted to call addTrack on a closed peerconnection.'); let n; if (this.transceivers.find(((e) => e.track === t))) throw c('InvalidAccessError', 'Track already exists.'); for (let i = 0; i < this.transceivers.length; i++) this.transceivers[i].track || this.transceivers[i].kind !== t.kind || (n = this.transceivers[i]); return n || (n = this._createTransceiver(t.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(r) === -1 && this.localStreams.push(r), n.track = t, n.stream = r, n.rtpSender = new e.RTCRtpSender(t, n.dtlsTransport), n.rtpSender; }, p.prototype.addStream = function (e) { const r = this; if (t >= 15025) e.getTracks().forEach(((t) => { r.addTrack(t, e); })); else { const n = e.clone(); e.getTracks().forEach(((e, t) => { const r = n.getTracks()[t]; e.addEventListener('enabled', ((e) => { r.enabled = e.enabled; })); })), n.getTracks().forEach(((e) => { r.addTrack(e, n); })); } }, p.prototype.removeTrack = function (t) { if (this._isClosed) throw c('InvalidStateError', 'Attempted to call removeTrack on a closed peerconnection.'); if (!(t instanceof e.RTCRtpSender)) throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.'); const r = this.transceivers.find(((e) => e.rtpSender === t)); if (!r) throw c('InvalidAccessError', 'Sender was not created by this connection.'); const n = r.stream; r.rtpSender.stop(), r.rtpSender = null, r.track = null, r.stream = null, this.transceivers.map(((e) => e.stream)).indexOf(n) === -1 && this.localStreams.indexOf(n) > -1 && this.localStreams.splice(this.localStreams.indexOf(n), 1), this._maybeFireNegotiationNeeded(); }, p.prototype.removeStream = function (e) { const t = this; e.getTracks().forEach(((e) => { const r = t.getSenders().find(((t) => t.track === e)); r && t.removeTrack(r); })); }, p.prototype.getSenders = function () { return this.transceivers.filter(((e) => !!e.rtpSender)).map(((e) => e.rtpSender)); }, p.prototype.getReceivers = function () { return this.transceivers.filter(((e) => !!e.rtpReceiver)).map(((e) => e.rtpReceiver)); }, p.prototype._createIceGatherer = function (t, r) { const n = this; if (r && t > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); const i = new e.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(i, 'state', { value: 'new', writable: !0 }), this.transceivers[t].bufferedCandidateEvents = [], this.transceivers[t].bufferCandidates = function (e) { const r = !e.candidate || Object.keys(e.candidate).length === 0; i.state = r ? 'completed' : 'gathering', n.transceivers[t].bufferedCandidateEvents !== null && n.transceivers[t].bufferedCandidateEvents.push(e); }, i.addEventListener('localcandidate', this.transceivers[t].bufferCandidates), i; }, p.prototype._gather = function (t, r) { const i = this; const a = this.transceivers[r].iceGatherer; if (!a.onlocalcandidate) { const o = this.transceivers[r].bufferedCandidateEvents; this.transceivers[r].bufferedCandidateEvents = null, a.removeEventListener('localcandidate', this.transceivers[r].bufferCandidates), a.onlocalcandidate = function (e) { if (!(i.usingBundle && r > 0)) { const o = new Event('icecandidate'); o.candidate = { sdpMid: t, sdpMLineIndex: r }; const s = e.candidate; const c = !s || Object.keys(s).length === 0; if (c) a.state !== 'new' && a.state !== 'gathering' || (a.state = 'completed'); else { a.state === 'new' && (a.state = 'gathering'), s.component = 1, s.ufrag = a.getLocalParameters().usernameFragment; const d = n.writeCandidate(s); o.candidate = Object.assign(o.candidate, n.parseCandidate(d)), o.candidate.candidate = d, o.candidate.toJSON = function () { return { candidate: o.candidate.candidate, sdpMid: o.candidate.sdpMid, sdpMLineIndex: o.candidate.sdpMLineIndex, usernameFragment: o.candidate.usernameFragment }; }; } const p = n.getMediaSections(i._localDescription.sdp); p[o.candidate.sdpMLineIndex] += c ? 'a=end-of-candidates\r\n' : `a=${o.candidate.candidate}\r\n`, i._localDescription.sdp = n.getDescription(i._localDescription.sdp) + p.join(''); const u = i.transceivers.every(((e) => e.iceGatherer && e.iceGatherer.state === 'completed')); i.iceGatheringState !== 'gathering' && (i.iceGatheringState = 'gathering', i._emitGatheringStateChange()), c || i._dispatchEvent('icecandidate', o), u && (i._dispatchEvent('icecandidate', new Event('icecandidate')), i.iceGatheringState = 'complete', i._emitGatheringStateChange()); } }, e.setTimeout((() => { o.forEach(((e) => { a.onlocalcandidate(e); })); }), 0); } }, p.prototype._createIceAndDtlsTransports = function () { const t = this; const r = new e.RTCIceTransport(null); r.onicestatechange = function () { t._updateIceConnectionState(), t._updateConnectionState(); }; const n = new e.RTCDtlsTransport(r); return n.ondtlsstatechange = function () { t._updateConnectionState(); }, n.onerror = function () { Object.defineProperty(n, 'state', { value: 'failed', writable: !0 }), t._updateConnectionState(); }, { iceTransport: r, dtlsTransport: n }; }, p.prototype._disposeIceAndDtlsTransports = function (e) { const t = this.transceivers[e].iceGatherer; t && (delete t.onlocalcandidate, delete this.transceivers[e].iceGatherer); const r = this.transceivers[e].iceTransport; r && (delete r.onicestatechange, delete this.transceivers[e].iceTransport); const n = this.transceivers[e].dtlsTransport; n && (delete n.ondtlsstatechange, delete n.onerror, delete this.transceivers[e].dtlsTransport); }, p.prototype._transceive = function (e, r, i) { const o = a(e.localCapabilities, e.remoteCapabilities); r && e.rtpSender && (o.encodings = e.sendEncodingParameters, o.rtcp = { cname: n.localCName, compound: e.rtcpParameters.compound }, e.recvEncodingParameters.length && (o.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(o)), i && e.rtpReceiver && o.codecs.length > 0 && (e.kind === 'video' && e.recvEncodingParameters && t < 15019 && e.recvEncodingParameters.forEach(((e) => { delete e.rtx; })), e.recvEncodingParameters.length ? o.encodings = e.recvEncodingParameters : o.encodings = [{}], o.rtcp = { compound: e.rtcpParameters.compound }, e.rtcpParameters.cname && (o.rtcp.cname = e.rtcpParameters.cname), e.sendEncodingParameters.length && (o.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(o)); }, p.prototype.setLocalDescription = function (e) { let t; let r; const i = this; if (['offer', 'answer'].indexOf(e.type) === -1) return Promise.reject(c('TypeError', `Unsupported type "${e.type}"`)); if (!o('setLocalDescription', e.type, i.signalingState) || i._isClosed) return Promise.reject(c('InvalidStateError', `Can not set local ${e.type} in state ${i.signalingState}`)); if (e.type === 'offer') t = n.splitSections(e.sdp), r = t.shift(), t.forEach(((e, t) => { const r = n.parseRtpParameters(e); i.transceivers[t].localCapabilities = r; })), i.transceivers.forEach(((e, t) => { i._gather(e.mid, t); })); else if (e.type === 'answer') { t = n.splitSections(i._remoteDescription.sdp), r = t.shift(); const s = n.matchPrefix(r, 'a=ice-lite').length > 0; t.forEach(((e, t) => { const o = i.transceivers[t]; const c = o.iceGatherer; const d = o.iceTransport; const p = o.dtlsTransport; const u = o.localCapabilities; const f = o.remoteCapabilities; if (!(n.isRejected(e) && n.matchPrefix(e, 'a=bundle-only').length === 0) && !o.rejected) { const l = n.getIceParameters(e, r); const m = n.getDtlsParameters(e, r); s && (m.role = 'server'), i.usingBundle && t !== 0 || (i._gather(o.mid, t), d.state === 'new' && d.start(c, l, s ? 'controlling' : 'controlled'), p.state === 'new' && p.start(m)); const h = a(u, f); i._transceive(o, h.codecs.length > 0, !1); } })); } return i._localDescription = { type: e.type, sdp: e.sdp }, e.type === 'offer' ? i._updateSignalingState('have-local-offer') : i._updateSignalingState('stable'), Promise.resolve(); }, p.prototype.setRemoteDescription = function (i) { const p = this; if (['offer', 'answer'].indexOf(i.type) === -1) return Promise.reject(c('TypeError', `Unsupported type "${i.type}"`)); if (!o('setRemoteDescription', i.type, p.signalingState) || p._isClosed) return Promise.reject(c('InvalidStateError', `Can not set remote ${i.type} in state ${p.signalingState}`)); const u = {}; p.remoteStreams.forEach(((e) => { u[e.id] = e; })); const f = []; const l = n.splitSections(i.sdp); const m = l.shift(); const h = n.matchPrefix(m, 'a=ice-lite').length > 0; const v = n.matchPrefix(m, 'a=group:BUNDLE ').length > 0; p.usingBundle = v; const y = n.matchPrefix(m, 'a=ice-options:')[0]; return p.canTrickleIceCandidates = !!y && y.substr(14).split(' ').indexOf('trickle') >= 0, l.forEach(((o, c) => { const d = n.splitLines(o); const l = n.getKind(o); const y = n.isRejected(o) && n.matchPrefix(o, 'a=bundle-only').length === 0; const g = d[0].substr(2).split(' ')[2]; const C = n.getDirection(o, m); const S = n.parseMsid(o); const T = n.getMid(o) || n.generateIdentifier(); if (y || l === 'application' && (g === 'DTLS/SCTP' || g === 'UDP/DTLS/SCTP')) p.transceivers[c] = { mid: T, kind: l, protocol: g, rejected: !0 }; else { let P; let R; let b; let E; let _; let w; let k; let x; let M; !y && p.transceivers[c] && p.transceivers[c].rejected && (p.transceivers[c] = p._createTransceiver(l, !0)); let D; let O; const I = n.parseRtpParameters(o); y || (D = n.getIceParameters(o, m), (O = n.getDtlsParameters(o, m)).role = 'client'), k = n.parseRtpEncodingParameters(o); const j = n.parseRtcpParameters(o); const L = n.matchPrefix(o, 'a=end-of-candidates', m).length > 0; const G = n.matchPrefix(o, 'a=candidate:').map(((e) => n.parseCandidate(e))).filter(((e) => e.component === 1)); if ((i.type === 'offer' || i.type === 'answer') && !y && v && c > 0 && p.transceivers[c] && (p._disposeIceAndDtlsTransports(c), p.transceivers[c].iceGatherer = p.transceivers[0].iceGatherer, p.transceivers[c].iceTransport = p.transceivers[0].iceTransport, p.transceivers[c].dtlsTransport = p.transceivers[0].dtlsTransport, p.transceivers[c].rtpSender && p.transceivers[c].rtpSender.setTransport(p.transceivers[0].dtlsTransport), p.transceivers[c].rtpReceiver && p.transceivers[c].rtpReceiver.setTransport(p.transceivers[0].dtlsTransport)), i.type !== 'offer' || y) { if (i.type === 'answer' && !y) { R = (P = p.transceivers[c]).iceGatherer, b = P.iceTransport, E = P.dtlsTransport, _ = P.rtpReceiver, w = P.sendEncodingParameters, x = P.localCapabilities, p.transceivers[c].recvEncodingParameters = k, p.transceivers[c].remoteCapabilities = I, p.transceivers[c].rtcpParameters = j, G.length && b.state === 'new' && (!h && !L || v && c !== 0 ? G.forEach(((e) => { s(P.iceTransport, e); })) : b.setRemoteCandidates(G)), v && c !== 0 || (b.state === 'new' && b.start(R, D, 'controlling'), E.state === 'new' && E.start(O)), !a(P.localCapabilities, P.remoteCapabilities).codecs.filter(((e) => e.name.toLowerCase() === 'rtx')).length && P.sendEncodingParameters[0].rtx && delete P.sendEncodingParameters[0].rtx, p._transceive(P, C === 'sendrecv' || C === 'recvonly', C === 'sendrecv' || C === 'sendonly'), !_ || C !== 'sendrecv' && C !== 'sendonly' ? delete P.rtpReceiver : (M = _.track, S ? (u[S.stream] || (u[S.stream] = new e.MediaStream()), r(M, u[S.stream]), f.push([M, _, u[S.stream]])) : (u.default || (u.default = new e.MediaStream()), r(M, u.default), f.push([M, _, u.default]))); } } else { (P = p.transceivers[c] || p._createTransceiver(l)).mid = T, P.iceGatherer || (P.iceGatherer = p._createIceGatherer(c, v)), G.length && P.iceTransport.state === 'new' && (!L || v && c !== 0 ? G.forEach(((e) => { s(P.iceTransport, e); })) : P.iceTransport.setRemoteCandidates(G)), x = e.RTCRtpReceiver.getCapabilities(l), t < 15019 && (x.codecs = x.codecs.filter(((e) => e.name !== 'rtx'))), w = P.sendEncodingParameters || [{ ssrc: 1001 * (2 * c + 2) }]; let A; let N = !1; if (C === 'sendrecv' || C === 'sendonly') { if (N = !P.rtpReceiver, _ = P.rtpReceiver || new e.RTCRtpReceiver(P.dtlsTransport, l), N) M = _.track, S && S.stream === '-' || (S ? (u[S.stream] || (u[S.stream] = new e.MediaStream(), Object.defineProperty(u[S.stream], 'id', { get() { return S.stream; } })), Object.defineProperty(M, 'id', { get() { return S.track; } }), A = u[S.stream]) : (u.default || (u.default = new e.MediaStream()), A = u.default)), A && (r(M, A), P.associatedRemoteMediaStreams.push(A)), f.push([M, _, A]); } else P.rtpReceiver && P.rtpReceiver.track && (P.associatedRemoteMediaStreams.forEach(((t) => { const r = t.getTracks().find(((e) => e.id === P.rtpReceiver.track.id)); r && (function (t, r) { r.removeTrack(t), r.dispatchEvent(new e.MediaStreamTrackEvent('removetrack', { track: t })); }(r, t)); })), P.associatedRemoteMediaStreams = []); P.localCapabilities = x, P.remoteCapabilities = I, P.rtpReceiver = _, P.rtcpParameters = j, P.sendEncodingParameters = w, P.recvEncodingParameters = k, p._transceive(p.transceivers[c], !1, N); } } })), void 0 === p._dtlsRole && (p._dtlsRole = i.type === 'offer' ? 'active' : 'passive'), p._remoteDescription = { type: i.type, sdp: i.sdp }, i.type === 'offer' ? p._updateSignalingState('have-remote-offer') : p._updateSignalingState('stable'), Object.keys(u).forEach(((t) => { const r = u[t]; if (r.getTracks().length) { if (p.remoteStreams.indexOf(r) === -1) { p.remoteStreams.push(r); const n = new Event('addstream'); n.stream = r, e.setTimeout((() => { p._dispatchEvent('addstream', n); })); } f.forEach(((e) => { const t = e[0]; const n = e[1]; r.id === e[2].id && d(p, t, n, [r]); })); } })), f.forEach(((e) => { e[2] || d(p, e[0], e[1], []); })), e.setTimeout((() => { p && p.transceivers && p.transceivers.forEach(((e) => { e.iceTransport && e.iceTransport.state === 'new' && e.iceTransport.getRemoteCandidates().length > 0 && (console.warn('Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification'), e.iceTransport.addRemoteCandidate({})); })); }), 4e3), Promise.resolve(); }, p.prototype.close = function () { this.transceivers.forEach(((e) => { e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop(); })), this._isClosed = !0, this._updateSignalingState('closed'); }, p.prototype._updateSignalingState = function (e) { this.signalingState = e; const t = new Event('signalingstatechange'); this._dispatchEvent('signalingstatechange', t); }, p.prototype._maybeFireNegotiationNeeded = function () { const t = this; this.signalingState === 'stable' && !0 !== this.needNegotiation && (this.needNegotiation = !0, e.setTimeout((() => { if (t.needNegotiation) { t.needNegotiation = !1; const e = new Event('negotiationneeded'); t._dispatchEvent('negotiationneeded', e); } }), 0)); }, p.prototype._updateIceConnectionState = function () { let e; const t = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(((e) => { e.iceTransport && !e.rejected && t[e.iceTransport.state]++; })), e = 'new', t.failed > 0 ? e = 'failed' : t.checking > 0 ? e = 'checking' : t.disconnected > 0 ? e = 'disconnected' : t.new > 0 ? e = 'new' : t.connected > 0 ? e = 'connected' : t.completed > 0 && (e = 'completed'), e !== this.iceConnectionState) { this.iceConnectionState = e; const r = new Event('iceconnectionstatechange'); this._dispatchEvent('iceconnectionstatechange', r); } }, p.prototype._updateConnectionState = function () { let e; const t = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(((e) => { e.iceTransport && e.dtlsTransport && !e.rejected && (t[e.iceTransport.state]++, t[e.dtlsTransport.state]++); })), t.connected += t.completed, e = 'new', t.failed > 0 ? e = 'failed' : t.connecting > 0 ? e = 'connecting' : t.disconnected > 0 ? e = 'disconnected' : t.new > 0 ? e = 'new' : t.connected > 0 && (e = 'connected'), e !== this.connectionState) { this.connectionState = e; const r = new Event('connectionstatechange'); this._dispatchEvent('connectionstatechange', r); } }, p.prototype.createOffer = function () { const r = this; if (r._isClosed) return Promise.reject(c('InvalidStateError', 'Can not call createOffer after close')); let a = r.transceivers.filter(((e) => e.kind === 'audio')).length; let o = r.transceivers.filter(((e) => e.kind === 'video')).length; const s = arguments[0]; if (s) { if (s.mandatory || s.optional) throw new TypeError('Legacy mandatory/optional constraints not supported.'); void 0 !== s.offerToReceiveAudio && (a = !0 === s.offerToReceiveAudio ? 1 : !1 === s.offerToReceiveAudio ? 0 : s.offerToReceiveAudio), void 0 !== s.offerToReceiveVideo && (o = !0 === s.offerToReceiveVideo ? 1 : !1 === s.offerToReceiveVideo ? 0 : s.offerToReceiveVideo); } for (r.transceivers.forEach(((e) => { e.kind === 'audio' ? --a < 0 && (e.wantReceive = !1) : e.kind === 'video' && --o < 0 && (e.wantReceive = !1); })); a > 0 || o > 0;)a > 0 && (r._createTransceiver('audio'), a--), o > 0 && (r._createTransceiver('video'), o--); let d = n.writeSessionBoilerplate(r._sdpSessionId, r._sdpSessionVersion++); r.transceivers.forEach(((i, a) => { const o = i.track; const s = i.kind; const c = i.mid || n.generateIdentifier(); i.mid = c, i.iceGatherer || (i.iceGatherer = r._createIceGatherer(a, r.usingBundle)); const d = e.RTCRtpSender.getCapabilities(s); t < 15019 && (d.codecs = d.codecs.filter(((e) => e.name !== 'rtx'))), d.codecs.forEach(((e) => { e.name === 'H264' && void 0 === e.parameters['level-asymmetry-allowed'] && (e.parameters['level-asymmetry-allowed'] = '1'), i.remoteCapabilities && i.remoteCapabilities.codecs && i.remoteCapabilities.codecs.forEach(((t) => { e.name.toLowerCase() === t.name.toLowerCase() && e.clockRate === t.clockRate && (e.preferredPayloadType = t.payloadType); })); })), d.headerExtensions.forEach(((e) => { (i.remoteCapabilities && i.remoteCapabilities.headerExtensions || []).forEach(((t) => { e.uri === t.uri && (e.id = t.id); })); })); const p = i.sendEncodingParameters || [{ ssrc: 1001 * (2 * a + 1) }]; o && t >= 15019 && s === 'video' && !p[0].rtx && (p[0].rtx = { ssrc: p[0].ssrc + 1 }), i.wantReceive && (i.rtpReceiver = new e.RTCRtpReceiver(i.dtlsTransport, s)), i.localCapabilities = d, i.sendEncodingParameters = p; })), r._config.bundlePolicy !== 'max-compat' && (d += `a=group:BUNDLE ${r.transceivers.map(((e) => e.mid)).join(' ')}\r\n`), d += 'a=ice-options:trickle\r\n', r.transceivers.forEach(((e, t) => { d += i(e, e.localCapabilities, 'offer', e.stream, r._dtlsRole), d += 'a=rtcp-rsize\r\n', !e.iceGatherer || r.iceGatheringState === 'new' || t !== 0 && r.usingBundle || (e.iceGatherer.getLocalCandidates().forEach(((e) => { e.component = 1, d += `a=${n.writeCandidate(e)}\r\n`; })), e.iceGatherer.state === 'completed' && (d += 'a=end-of-candidates\r\n')); })); const p = new e.RTCSessionDescription({ type: 'offer', sdp: d }); return Promise.resolve(p); }, p.prototype.createAnswer = function () { const r = this; if (r._isClosed) return Promise.reject(c('InvalidStateError', 'Can not call createAnswer after close')); if (r.signalingState !== 'have-remote-offer' && r.signalingState !== 'have-local-pranswer') return Promise.reject(c('InvalidStateError', `Can not call createAnswer in signalingState ${r.signalingState}`)); let o = n.writeSessionBoilerplate(r._sdpSessionId, r._sdpSessionVersion++); r.usingBundle && (o += `a=group:BUNDLE ${r.transceivers.map(((e) => e.mid)).join(' ')}\r\n`), o += 'a=ice-options:trickle\r\n'; const s = n.getMediaSections(r._remoteDescription.sdp).length; r.transceivers.forEach(((e, n) => { if (!(n + 1 > s)) { if (e.rejected) return e.kind === 'application' ? e.protocol === 'DTLS/SCTP' ? o += 'm=application 0 DTLS/SCTP 5000\r\n' : o += `m=application 0 ${e.protocol} webrtc-datachannel\r\n` : e.kind === 'audio' ? o += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n' : e.kind === 'video' && (o += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n'), void (o += `c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:${e.mid}\r\n`); let c; if (e.stream) e.kind === 'audio' ? c = e.stream.getAudioTracks()[0] : e.kind === 'video' && (c = e.stream.getVideoTracks()[0]), c && t >= 15019 && e.kind === 'video' && !e.sendEncodingParameters[0].rtx && (e.sendEncodingParameters[0].rtx = { ssrc: e.sendEncodingParameters[0].ssrc + 1 }); const d = a(e.localCapabilities, e.remoteCapabilities); !d.codecs.filter(((e) => e.name.toLowerCase() === 'rtx')).length && e.sendEncodingParameters[0].rtx && delete e.sendEncodingParameters[0].rtx, o += i(e, d, 'answer', e.stream, r._dtlsRole), e.rtcpParameters && e.rtcpParameters.reducedSize && (o += 'a=rtcp-rsize\r\n'); } })); const d = new e.RTCSessionDescription({ type: 'answer', sdp: o }); return Promise.resolve(d); }, p.prototype.addIceCandidate = function (e) { let t; const r = this; return e && void 0 === e.sdpMLineIndex && !e.sdpMid ? Promise.reject(new TypeError('sdpMLineIndex or sdpMid required')) : new Promise(((i, a) => { if (!r._remoteDescription) return a(c('InvalidStateError', 'Can not add ICE candidate without a remote description')); if (e && e.candidate !== '') { let o = e.sdpMLineIndex; if (e.sdpMid) for (let d = 0; d < r.transceivers.length; d++) if (r.transceivers[d].mid === e.sdpMid) { o = d; break; } const p = r.transceivers[o]; if (!p) return a(c('OperationError', 'Can not add ICE candidate')); if (p.rejected) return i(); const u = Object.keys(e.candidate).length > 0 ? n.parseCandidate(e.candidate) : {}; if (u.protocol === 'tcp' && (u.port === 0 || u.port === 9)) return i(); if (u.component && u.component !== 1) return i(); if ((o === 0 || o > 0 && p.iceTransport !== r.transceivers[0].iceTransport) && !s(p.iceTransport, u)) return a(c('OperationError', 'Can not add ICE candidate')); let f = e.candidate.trim(); f.indexOf('a=') === 0 && (f = f.substr(2)), (t = n.getMediaSections(r._remoteDescription.sdp))[o] += `a=${u.type ? f : 'end-of-candidates'}\r\n`, r._remoteDescription.sdp = n.getDescription(r._remoteDescription.sdp) + t.join(''); } else for (let l = 0; l < r.transceivers.length && (r.transceivers[l].rejected || (r.transceivers[l].iceTransport.addRemoteCandidate({}), (t = n.getMediaSections(r._remoteDescription.sdp))[l] += 'a=end-of-candidates\r\n', r._remoteDescription.sdp = n.getDescription(r._remoteDescription.sdp) + t.join(''), !r.usingBundle)); l++); i(); })); }, p.prototype.getStats = function (t) { if (t && t instanceof e.MediaStreamTrack) { let r = null; if (this.transceivers.forEach(((e) => { e.rtpSender && e.rtpSender.track === t ? r = e.rtpSender : e.rtpReceiver && e.rtpReceiver.track === t && (r = e.rtpReceiver); })), !r) throw c('InvalidAccessError', 'Invalid selector.'); return r.getStats(); } const n = []; return this.transceivers.forEach(((e) => { ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(((t) => { e[t] && n.push(e[t].getStats()); })); })), Promise.all(n).then(((e) => { const t = new Map(); return e.forEach(((e) => { e.forEach(((e) => { t.set(e.id, e); })); })), t; })); };['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer', 'RTCIceTransport', 'RTCDtlsTransport'].forEach(((t) => { const r = e[t]; if (r && r.prototype && r.prototype.getStats) { const n = r.prototype.getStats; r.prototype.getStats = function () { return n.apply(this).then(((e) => { const t = new Map(); return Object.keys(e).forEach(((r) => { let n; e[r].type = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[(n = e[r]).type] || n.type, t.set(r, e[r]); })), t; })); }; } })); let u = ['createOffer', 'createAnswer']; return u.forEach(((e) => { const t = p.prototype[e]; p.prototype[e] = function () { const e = arguments; return typeof e[0] === 'function' || typeof e[1] === 'function' ? t.apply(this, [arguments[2]]).then(((t) => { typeof e[0] === 'function' && e[0].apply(null, [t]); }), ((t) => { typeof e[1] === 'function' && e[1].apply(null, [t]); })) : t.apply(this, arguments); }; })), (u = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']).forEach(((e) => { const t = p.prototype[e]; p.prototype[e] = function () { const e = arguments; return typeof e[1] === 'function' || typeof e[2] === 'function' ? t.apply(this, arguments).then((() => { typeof e[1] === 'function' && e[1].apply(null); }), ((t) => { typeof e[2] === 'function' && e[2].apply(null, [t]); })) : t.apply(this, arguments); }; })), ['getStats'].forEach(((e) => { const t = p.prototype[e]; p.prototype[e] = function () { const e = arguments; return typeof e[1] === 'function' ? t.apply(this, arguments).then((() => { typeof e[1] === 'function' && e[1].apply(null); })) : t.apply(this, arguments); }; })), p; };
  }, { sdp: 17 }],
  17: [function (e, t, r) {
    const n = { generateIdentifier() { return Math.random().toString(36).substr(2, 10); } }; n.localCName = n.generateIdentifier(), n.splitLines = function (e) { return e.trim().split('\n').map(((e) => e.trim())); }, n.splitSections = function (e) { return e.split('\nm=').map(((e, t) => `${(t > 0 ? `m=${e}` : e).trim()}\r\n`)); }, n.getDescription = function (e) { const t = n.splitSections(e); return t && t[0]; }, n.getMediaSections = function (e) { const t = n.splitSections(e); return t.shift(), t; }, n.matchPrefix = function (e, t) { return n.splitLines(e).filter(((e) => e.indexOf(t) === 0)); }, n.parseCandidate = function (e) { for (var t, r = { foundation: (t = e.indexOf('a=candidate:') === 0 ? e.substring(12).split(' ') : e.substring(10).split(' '))[0], component: parseInt(t[1], 10), protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }, n = 8; n < t.length; n += 2) switch (t[n]) { case 'raddr': r.relatedAddress = t[n + 1]; break; case 'rport': r.relatedPort = parseInt(t[n + 1], 10); break; case 'tcptype': r.tcpType = t[n + 1]; break; case 'ufrag': r.ufrag = t[n + 1], r.usernameFragment = t[n + 1]; break; default: r[t[n]] = t[n + 1]; } return r; }, n.writeCandidate = function (e) { const t = []; t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); const r = e.type; return t.push('typ'), t.push(r), r !== 'host' && e.relatedAddress && e.relatedPort && (t.push('raddr'), t.push(e.relatedAddress), t.push('rport'), t.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === 'tcp' && (t.push('tcptype'), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push('ufrag'), t.push(e.usernameFragment || e.ufrag)), `candidate:${t.join(' ')}`; }, n.parseIceOptions = function (e) { return e.substr(14).split(' '); }, n.parseRtpMap = function (e) { let t = e.substr(9).split(' '); const r = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split('/'), r.name = t[0], r.clockRate = parseInt(t[1], 10), r.channels = t.length === 3 ? parseInt(t[2], 10) : 1, r.numChannels = r.channels, r; }, n.writeRtpMap = function (e) { let t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); const r = e.channels || e.numChannels || 1; return `a=rtpmap:${t} ${e.name}/${e.clockRate}${r !== 1 ? `/${r}` : ''}\r\n`; }, n.parseExtmap = function (e) { const t = e.substr(9).split(' '); return { id: parseInt(t[0], 10), direction: t[0].indexOf('/') > 0 ? t[0].split('/')[1] : 'sendrecv', uri: t[1] }; }, n.writeExtmap = function (e) { return `a=extmap:${e.id || e.preferredId}${e.direction && e.direction !== 'sendrecv' ? `/${e.direction}` : ''} ${e.uri}\r\n`; }, n.parseFmtp = function (e) { for (var t, r = {}, n = e.substr(e.indexOf(' ') + 1).split(';'), i = 0; i < n.length; i++)r[(t = n[i].trim().split('='))[0].trim()] = t[1]; return r; }, n.writeFmtp = function (e) { let t = ''; let r = e.payloadType; if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { const n = []; Object.keys(e.parameters).forEach(((t) => { e.parameters[t] ? n.push(`${t}=${e.parameters[t]}`) : n.push(t); })), t += `a=fmtp:${r} ${n.join(';')}\r\n`; } return t; }, n.parseRtcpFb = function (e) { const t = e.substr(e.indexOf(' ') + 1).split(' '); return { type: t.shift(), parameter: t.join(' ') }; }, n.writeRtcpFb = function (e) { let t = ''; let r = e.payloadType; return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(((e) => { t += `a=rtcp-fb:${r} ${e.type}${e.parameter && e.parameter.length ? ` ${e.parameter}` : ''}\r\n`; })), t; }, n.parseSsrcMedia = function (e) { const t = e.indexOf(' '); const r = { ssrc: parseInt(e.substr(7, t - 7), 10) }; const n = e.indexOf(':', t); return n > -1 ? (r.attribute = e.substr(t + 1, n - t - 1), r.value = e.substr(n + 1)) : r.attribute = e.substr(t + 1), r; }, n.parseSsrcGroup = function (e) { const t = e.substr(13).split(' '); return { semantics: t.shift(), ssrcs: t.map(((e) => parseInt(e, 10))) }; }, n.getMid = function (e) { const t = n.matchPrefix(e, 'a=mid:')[0]; if (t) return t.substr(6); }, n.parseFingerprint = function (e) { const t = e.substr(14).split(' '); return { algorithm: t[0].toLowerCase(), value: t[1] }; }, n.getDtlsParameters = function (e, t) { return { role: 'auto', fingerprints: n.matchPrefix(e + t, 'a=fingerprint:').map(n.parseFingerprint) }; }, n.writeDtlsParameters = function (e, t) { let r = `a=setup:${t}\r\n`; return e.fingerprints.forEach(((e) => { r += `a=fingerprint:${e.algorithm} ${e.value}\r\n`; })), r; }, n.parseCryptoLine = function (e) { const t = e.substr(9).split(' '); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) }; }, n.writeCryptoLine = function (e) { return `a=crypto:${e.tag} ${e.cryptoSuite} ${typeof e.keyParams === 'object' ? n.writeCryptoKeyParams(e.keyParams) : e.keyParams}${e.sessionParams ? ` ${e.sessionParams.join(' ')}` : ''}\r\n`; }, n.parseCryptoKeyParams = function (e) { if (e.indexOf('inline:') !== 0) return null; const t = e.substr(7).split('|'); return { keyMethod: 'inline', keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(':')[0] : void 0, mkiLength: t[2] ? t[2].split(':')[1] : void 0 }; }, n.writeCryptoKeyParams = function (e) { return `${e.keyMethod}:${e.keySalt}${e.lifeTime ? `|${e.lifeTime}` : ''}${e.mkiValue && e.mkiLength ? `|${e.mkiValue}:${e.mkiLength}` : ''}`; }, n.getCryptoParameters = function (e, t) { return n.matchPrefix(e + t, 'a=crypto:').map(n.parseCryptoLine); }, n.getIceParameters = function (e, t) { const r = n.matchPrefix(e + t, 'a=ice-ufrag:')[0]; const i = n.matchPrefix(e + t, 'a=ice-pwd:')[0]; return r && i ? { usernameFragment: r.substr(12), password: i.substr(10) } : null; }, n.writeIceParameters = function (e) { return `a=ice-ufrag:${e.usernameFragment}\r\na=ice-pwd:${e.password}\r\n`; }, n.parseRtpParameters = function (e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = n.splitLines(e)[0].split(' '), i = 3; i < r.length; i++) { const a = r[i]; const o = n.matchPrefix(e, `a=rtpmap:${a} `)[0]; if (o) { const s = n.parseRtpMap(o); const c = n.matchPrefix(e, `a=fmtp:${a} `); switch (s.parameters = c.length ? n.parseFmtp(c[0]) : {}, s.rtcpFeedback = n.matchPrefix(e, `a=rtcp-fb:${a} `).map(n.parseRtcpFb), t.codecs.push(s), s.name.toUpperCase()) { case 'RED': case 'ULPFEC': t.fecMechanisms.push(s.name.toUpperCase()); } } } return n.matchPrefix(e, 'a=extmap:').forEach(((e) => { t.headerExtensions.push(n.parseExtmap(e)); })), t; }, n.writeRtpDescription = function (e, t) { let r = ''; r += `m=${e} `, r += t.codecs.length > 0 ? '9' : '0', r += ' UDP/TLS/RTP/SAVPF ', r += `${t.codecs.map(((e) => (void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType))).join(' ')}\r\n`, r += 'c=IN IP4 0.0.0.0\r\n', r += 'a=rtcp:9 IN IP4 0.0.0.0\r\n', t.codecs.forEach(((e) => { r += n.writeRtpMap(e), r += n.writeFmtp(e), r += n.writeRtcpFb(e); })); let i = 0; return t.codecs.forEach(((e) => { e.maxptime > i && (i = e.maxptime); })), i > 0 && (r += `a=maxptime:${i}\r\n`), r += 'a=rtcp-mux\r\n', t.headerExtensions && t.headerExtensions.forEach(((e) => { r += n.writeExtmap(e); })), r; }, n.parseRtpEncodingParameters = function (e) { let t; const r = []; const i = n.parseRtpParameters(e); const a = i.fecMechanisms.indexOf('RED') !== -1; const o = i.fecMechanisms.indexOf('ULPFEC') !== -1; const s = n.matchPrefix(e, 'a=ssrc:').map(((e) => n.parseSsrcMedia(e))).filter(((e) => e.attribute === 'cname')); const c = s.length > 0 && s[0].ssrc; const d = n.matchPrefix(e, 'a=ssrc-group:FID').map(((e) => e.substr(17).split(' ').map(((e) => parseInt(e, 10))))); d.length > 0 && d[0].length > 1 && d[0][0] === c && (t = d[0][1]), i.codecs.forEach(((e) => { if (e.name.toUpperCase() === 'RTX' && e.parameters.apt) { let n = { ssrc: c, codecPayloadType: parseInt(e.parameters.apt, 10) }; c && t && (n.rtx = { ssrc: t }), r.push(n), a && ((n = JSON.parse(JSON.stringify(n))).fec = { ssrc: c, mechanism: o ? 'red+ulpfec' : 'red' }, r.push(n)); } })), r.length === 0 && c && r.push({ ssrc: c }); let p = n.matchPrefix(e, 'b='); return p.length && (p = p[0].indexOf('b=TIAS:') === 0 ? parseInt(p[0].substr(7), 10) : p[0].indexOf('b=AS:') === 0 ? 1e3 * parseInt(p[0].substr(5), 10) * 0.95 - 16e3 : void 0, r.forEach(((e) => { e.maxBitrate = p; }))), r; }, n.parseRtcpParameters = function (e) { const t = {}; const r = n.matchPrefix(e, 'a=ssrc:').map(((e) => n.parseSsrcMedia(e))).filter(((e) => e.attribute === 'cname'))[0]; r && (t.cname = r.value, t.ssrc = r.ssrc); const i = n.matchPrefix(e, 'a=rtcp-rsize'); t.reducedSize = i.length > 0, t.compound = i.length === 0; const a = n.matchPrefix(e, 'a=rtcp-mux'); return t.mux = a.length > 0, t; }, n.parseMsid = function (e) { let t; const r = n.matchPrefix(e, 'a=msid:'); if (r.length === 1) return { stream: (t = r[0].substr(7).split(' '))[0], track: t[1] }; const i = n.matchPrefix(e, 'a=ssrc:').map(((e) => n.parseSsrcMedia(e))).filter(((e) => e.attribute === 'msid')); return i.length > 0 ? { stream: (t = i[0].value.split(' '))[0], track: t[1] } : void 0; }, n.parseSctpDescription = function (e) { let t; const r = n.parseMLine(e); const i = n.matchPrefix(e, 'a=max-message-size:'); i.length > 0 && (t = parseInt(i[0].substr(19), 10)), isNaN(t) && (t = 65536); const a = n.matchPrefix(e, 'a=sctp-port:'); if (a.length > 0) return { port: parseInt(a[0].substr(12), 10), protocol: r.fmt, maxMessageSize: t }; if (n.matchPrefix(e, 'a=sctpmap:').length > 0) { const o = n.matchPrefix(e, 'a=sctpmap:')[0].substr(10).split(' '); return { port: parseInt(o[0], 10), protocol: o[1], maxMessageSize: t }; } }, n.writeSctpDescription = function (e, t) { let r = []; return r = e.protocol !== 'DTLS/SCTP' ? [`m=${e.kind} 9 ${e.protocol} ${t.protocol}\r\n`, 'c=IN IP4 0.0.0.0\r\n', `a=sctp-port:${t.port}\r\n`] : [`m=${e.kind} 9 ${e.protocol} ${t.port}\r\n`, 'c=IN IP4 0.0.0.0\r\n', `a=sctpmap:${t.port} ${t.protocol} 65535\r\n`], void 0 !== t.maxMessageSize && r.push(`a=max-message-size:${t.maxMessageSize}\r\n`), r.join(''); }, n.generateSessionId = function () { return Math.random().toString().substr(2, 21); }, n.writeSessionBoilerplate = function (e, t, r) { const i = void 0 !== t ? t : 2; return `v=0\r\no=${r || 'thisisadapterortc'} ${e || n.generateSessionId()} ${i} IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n`; }, n.writeMediaSection = function (e, t, r, i) { let a = n.writeRtpDescription(e.kind, t); if (a += n.writeIceParameters(e.iceGatherer.getLocalParameters()), a += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === 'offer' ? 'actpass' : 'active'), a += `a=mid:${e.mid}\r\n`, e.direction ? a += `a=${e.direction}\r\n` : e.rtpSender && e.rtpReceiver ? a += 'a=sendrecv\r\n' : e.rtpSender ? a += 'a=sendonly\r\n' : e.rtpReceiver ? a += 'a=recvonly\r\n' : a += 'a=inactive\r\n', e.rtpSender) { const o = `msid:${i.id} ${e.rtpSender.track.id}\r\n`; a += `a=${o}`, a += `a=ssrc:${e.sendEncodingParameters[0].ssrc} ${o}`, e.sendEncodingParameters[0].rtx && (a += `a=ssrc:${e.sendEncodingParameters[0].rtx.ssrc} ${o}`, a += `a=ssrc-group:FID ${e.sendEncodingParameters[0].ssrc} ${e.sendEncodingParameters[0].rtx.ssrc}\r\n`); } return a += `a=ssrc:${e.sendEncodingParameters[0].ssrc} cname:${n.localCName}\r\n`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += `a=ssrc:${e.sendEncodingParameters[0].rtx.ssrc} cname:${n.localCName}\r\n`), a; }, n.getDirection = function (e, t) { for (let r = n.splitLines(e), i = 0; i < r.length; i++) switch (r[i]) { case 'a=sendrecv': case 'a=sendonly': case 'a=recvonly': case 'a=inactive': return r[i].substr(2); } return t ? n.getDirection(t) : 'sendrecv'; }, n.getKind = function (e) { return n.splitLines(e)[0].split(' ')[0].substr(2); }, n.isRejected = function (e) { return e.split(' ', 2)[1] === '0'; }, n.parseMLine = function (e) { const t = n.splitLines(e)[0].substr(2).split(' '); return { kind: t[0], port: parseInt(t[1], 10), protocol: t[2], fmt: t.slice(3).join(' ') }; }, n.parseOLine = function (e) { const t = n.matchPrefix(e, 'o=')[0].substr(2).split(' '); return { username: t[0], sessionId: t[1], sessionVersion: parseInt(t[2], 10), netType: t[3], addressType: t[4], address: t[5] }; }, n.isValidSDP = function (e) { if (typeof e !== 'string' || e.length === 0) return !1; for (let t = n.splitLines(e), r = 0; r < t.length; r++) if (t[r].length < 2 || t[r].charAt(1) !== '=') return !1; return !0; }, typeof t === 'object' && (t.exports = n);
  }, {}]
}, {}, [1]))(1))));
